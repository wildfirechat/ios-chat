# 消息备份恢复功能设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 消息备份恢复功能设计文档 |
| 版本 | 2.0 |
| 创建日期 | 2025-01-10 |
| 最后更新 | 2025-01-10 |
| 状态 | 已实现 |

---

## 1. 功能概述

### 1.1 目标

为 iOS 聊天应用实现完整的消息备份和恢复功能，支持：

- **目录结构备份**：每个会话独立存储，结构清晰
- **选择性备份**：可选择特定会话或全部会话
- **媒体文件支持**：自动备份媒体文件到独立目录
- **加密保护**：可选的密码加密消息内容
- **进度跟踪**：实时显示备份/恢复进度
- **取消清理**：取消时自动清理不完整备份

### 1.2 核心特性

1. **分层存储结构**
   - 元数据文件（metadata.json）：不加密，便于查看备份信息
   - 会话目录：每个会话独立存储
   - 消息文件（messages.json）：加密存储，保护隐私
   - 媒体目录（media/）：明文存储，便于预览

2. **智能处理**
   - 自动提取并保存图片缩略图
   - 使用 MD5 去重媒体文件
   - 只统计实际备份的媒体文件
   - 自动处理路径映射

3. **用户体验**
   - 支持会话多选
   - 显示详细进度信息
   - 返回统计信息（消息数、媒体数、大小）
   - 取消时自动清理

---

## 2. 系统架构

### 2.1 组件关系

```
┌─────────────────────────────────────────────┐
│              UI Layer                       │
│  ┌──────────────────────────────────────┐  │
│  │  WFCConversationSelectViewController  │  │
│  │  WFCBackupOptionsViewController        │  │
│  │  WFCBackupProgressViewController       │  │
│  │  WFCBackupListViewController           │  │
│  │  WFCRestoreOptionsViewController       │  │
│  └──────────────────────────────────────┘  │
└──────────────────┬──────────────────────────┘
                   │
                   ↓
┌─────────────────────────────────────────────┐
│         Business Logic Layer                │
│  ┌──────────────────────────────────────┐  │
│  │   WFCCMessageBackupManager            │  │
│  │   - createDirectoryBasedBackup        │  │
│  │   - restoreFromBackup                 │  │
│  │   - getDirectoryBackupInfo            │  │
│  │   - cancelCurrentOperation            │  │
│  └──────────────────────────────────────┘  │
└──────────────────┬──────────────────────────┘
                   │
         ┌─────────┴─────────┐
         ↓                   ↓
┌──────────────────┐  ┌──────────────────┐
│ WFCCBackupCrypto  │  │  WFCCIMService   │
│  - 加密/解密      │  │  (SDK)           │
│  - 密钥派生       │  │  - 消息读写      │
│  - MD5计算       │  │  - 会话管理      │
└──────────────────┘  └──────────────────┘
```

### 2.2 数据流

**备份流程**：
```
用户选择会话
    ↓
备份选项配置
    ↓
创建备份目录结构
    ↓
遍历会话 → 获取消息
    ↓
编码消息 + 处理媒体
    ↓
加密 messages.json
    ↓
生成 metadata.json
    ↓
完成（返回统计）
```

**恢复流程**：
```
用户选择备份
    ↓
读取 metadata.json
    ↓
遍历会话列表
    ↓
解密 messages.json
    ↓
解码消息 + 恢复媒体
    ↓
插入数据库（通过SDK）
    ↓
完成（返回统计）
```

---

## 3. 数据格式设计

### 3.1 目录结构

```
backup_YYYY-MM-DD_HH-MM-SS/              # 备份根目录（时间戳）
├── metadata.json                         # 元数据文件（不加密）
└── conversations/                        # 会话子目录
    ├── conv_type{类型}_{target}_{line}/ # 单个会话目录
    │   ├── messages.json                # 消息文件（加密）
    │   └── media/                       # 媒体文件目录（不加密）
    │       ├── {MD5前16位}.jpg
    │       ├── {MD5前16位}.mp4
    │       └── {MD5前16位}.m4a
    └── ...
```

**命名规则**：
- 备份目录：`backup_YYYY-MM-DD_HH-MM-SS`
- 会话目录：`conv_type{type}_{target}_{line}`
  - type: 会话类型（1=单聊, 2=群聊, 3=聊天室, 4=频道）
  - target: 目标ID（**URL编码**，使用 `stringByAddingPercentEncodingWithAllowedCharacters:` 方法，避免特殊字符导致路径问题）
  - line: 线路号（通常为0）
- 媒体文件：`media_{MD5前16位}.{扩展名}`
  - 示例：`media_abc123def4567890.jpg`、`media_abc123def4567890.mp4`
  - 使用MD5的前16位作为文件ID
  - 保留原始文件的扩展名
  - 添加 `media_` 前缀以区分媒体文件

### 3.2 metadata.json 格式

**说明**：不加密，包含备份的基本信息和统计

```json
{
  "version": "1",
  "format": "directory",
  "backupTime": "2025-01-09T14:30:45Z",
  "userId": "user123",
  "appType": "ios-chat",
  "backupMode": "message_with_media",
  "encryption": {
    "enabled": true,
    "algorithm": "AES-256-CBC",
    "keyDerivation": "PBKDF2-SHA256",
    "passwordHint": "密码提示"
  },
  "statistics": {
    "totalConversations": 15,
    "totalMessages": 3250,
    "mediaFileCount": 48,
    "mediaTotalSize": 52428800,
    "timeRange": {
      "firstMessageTime": 1704800000000,
      "lastMessageTime": 1704809445000
    }
  },
  "conversations": [
    {
      "conversationId": "conv_type1_userA_line0",
      "type": 1,
      "target": "userA",
      "line": 0,
      "messageCount": 120,
      "mediaCount": 5,
      "directory": "conv_type1_userA_line0"
    }
  ]
}
```

**字段说明**：

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| version | String | ✅ | 备份格式版本号（当前为"1"） |
| format | String | ✅ | 格式类型（固定为"directory"） |
| backupTime | String | ✅ | 备份时间（ISO 8601格式） |
| userId | String | ✅ | 用户ID |
| appType | String | ✅ | 应用类型（ios-chat） |
| backupMode | String | ✅ | 备份模式（message_with_media） |
| encryption | Object | ✅ | 加密配置 |
| encryption.enabled | Boolean | ✅ | 是否启用加密 |
| encryption.algorithm | String | ✅ | 加密算法（AES-256-CBC） |
| encryption.keyDerivation | String | ✅ | 密钥派生算法（PBKDF2-SHA256） |
| encryption.passwordHint | String | ❌ | 密码提示 |
| statistics | Object | ✅ | 统计信息 |
| statistics.totalConversations | Number | ✅ | 会话总数 |
| statistics.totalMessages | Number | ✅ | 消息总数 |
| statistics.mediaFileCount | Number | ✅ | 媒体文件数量 |
| statistics.mediaTotalSize | Number | ✅ | 媒体文件总大小（字节） |
| statistics.timeRange | Object | ❌ | 时间范围 |
| conversations | Array | ✅ | 会话列表 |

### 3.3 messages.json 格式（加密）

**说明**：使用密码加密，包含会话的详细信息和消息列表

```json
{
  "version": "1",
  "conversation": {
    "type": 1,
    "target": "userA",
    "line": 0
  },
  "settings": {
    "isTop": 0,
    "isSilent": false,
    "draft": "草稿内容"
  },
  "messages": [
    {
      "messageUid": 1704800000000001,
      "fromUser": "userA",
      "toUsers": ["userB"],
      "direction": 0,
      "status": 0,
      "timestamp": 1704800000000,
      "localExtra": "",
      "payload": {
        "contentType": 1,
        "searchableContent": "消息内容",
        "pushContent": "",
        "pushData": "",
        "content": "",
        "binaryContent": "base64编码数据",
        "localContent": "",
        "mentionedType": 0,
        "mentionedTargets": [],
        "extra": "",
        "notLoaded": false,
        "mediaType": 0,
        "remoteMediaUrl": "https://...",
        "localMediaInfo": {
          "relativePath": "media_abc123.jpg",
          "fileId": "abc123def456",
          "fileSize": 102400,
          "md5": "hash值"
        }
      },
      "mediaFileSize": 102400
    }
  ]
}
```

**字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| version | String | 备份格式版本号 |
| conversation.type | Number | 会话类型 |
| conversation.target | String | 目标ID |
| conversation.line | Number | 线路号 |
| settings.isTop | Number | 置顶级别（0=不置顶） |
| settings.isSilent | Boolean | 是否免打扰 |
| settings.draft | String | 草稿内容 |
| messages | Array | 消息列表 |
| messages[].messageUid | Number | 消息全局唯一ID |
| messages[].fromUser | String | 发送者用户ID |
| messages[].toUsers | Array | 定向接收者列表 |
| messages[].direction | Number | 消息方向（0=发送, 1=接收） |
| messages[].status | Number | 消息状态 |
| messages[].timestamp | Number | 时间戳（毫秒） |
| messages[].localExtra | String | 本地附加信息 |
| messages[].payload | Object | 消息内容（MessagePayload格式） |
| messages[].payload.localMediaInfo | Object | 本地媒体文件信息（仅媒体消息） |
| messages[].mediaFileSize | Number | 媒体文件大小（字节） |

---

## 4. 接口设计

### 4.1 创建备份

```objc
- (void)createDirectoryBasedBackup:(NSString *)directoryPath
                      conversations:(nullable NSArray<WFCCConversationInfo *> *)conversations
                          password:(nullable NSString *)password
                      passwordHint:(nullable NSString *)passwordHint
                           progress:(nullable void(^)(NSProgress *progress))progress
                            success:(void(^)(NSString *backupPath, int msgCount, int mediaCount, long long mediaSize))success
                              error:(void(^)(int errorCode))error;
```

**参数说明**：

| 参数 | 类型 | 必需 | 说明 |
|------|------|------|------|
| directoryPath | String | ✅ | 备份文件夹路径 |
| conversations | Array | ❌ | 要备份的会话列表（nil=全部会话） |
| password | String | ❌ | 加密密码（nil=不加密）**注意**：UI层自动使用 `[WFCCNetworkService sharedInstance].userId` 作为密码 |
| passwordHint | String | ❌ | 密码提示 |
| progress | Block | ❌ | 进度回调 |
| success | Block | ✅ | 成功回调 |
| error | Block | ✅ | 失败回调 |

**密码策略**：
- **UI层实现**：备份和恢复时自动使用当前用户ID作为加密密码
- **实现位置**：`WFCBackupOptionsViewController` 和 `WFCRestoreOptionsViewController`
- **代码**：`vc.backupPassword = [WFCCNetworkService sharedInstance].userId;`
- **优点**：用户无需输入密码，备份自动加密，恢复自动解密

**返回值**（success回调）：

| 字段 | 类型 | 说明 |
|------|------|------|
| backupPath | String | 备份文件夹路径 |
| msgCount | int | 备份的消息总数 |
| mediaCount | int | 备份的媒体文件总数 |
| mediaSize | long long | 媒体文件总大小（字节） |

### 4.2 恢复备份

```objc
- (void)restoreFromBackup:(NSString *)directoryPath
                 password:(nullable NSString *)password
       overwriteExisting:(BOOL)overwriteExisting
                progress:(nullable void(^)(NSProgress *progress))progress
                 success:(void(^)(int msgCount, int mediaCount))success
                   error:(void(^)(int errorCode))error;
```

**参数说明**：

| 参数 | 类型 | 必需 | 说明 |
|------|------|------|------|
| directoryPath | String | ✅ | 备份文件夹路径 |
| password | String | ❌ | 解密密码（未加密则传nil） |
| overwriteExisting | Boolean | ✅ | 是否覆盖已存在的消息 |
| progress | Block | ❌ | 进度回调 |
| success | Block | ✅ | 成功回调 |
| error | Block | ✅ | 失败回调 |

**返回值**（success回调）：

| 字段 | 类型 | 说明 |
|------|------|------|
| msgCount | int | 恢复的消息总数 |
| mediaCount | int | 恢复的媒体文件总数 |

### 4.3 获取备份信息

```objc
- (nullable NSDictionary *)getDirectoryBackupInfo:(NSString *)directoryPath;
```

**返回字段**：

```objc
@{
  @"format": @"directory",
  @"isEncrypted": @YES,
  @"version": @"1",
  @"backupTime": @"2025-01-09T14:30:45Z",
  @"userId": @"user123",
  @"totalConversations": @15,
  @"totalMessages": @3250,
  @"mediaFileCount": @48,
  @"mediaTotalSize": @52428800,
  @"hasPasswordHint": @YES
}
```

### 4.4 取消操作

```objc
- (void)cancelCurrentOperation;
```

**说明**：
- 取消当前正在进行的备份或恢复操作
- 取消备份时会自动清理已创建的不完整备份目录
- 取消恢复时不会回滚已插入的消息

---

## 5. 加密设计

### 5.1 加密策略

**加密范围**：
- ✅ 加密：`conversations/{conv_id}/messages.json`
- ❌ 不加密：`metadata.json`、`conversations/{conv_id}/media/*`

**原因**：
- metadata.json 包含非敏感的统计信息，明文便于查看
- 媒体文件较大，加密会影响性能
- 消息内容包含隐私，需要加密保护

### 5.2 加密算法

| 项目 | 值 |
|------|-----|
| 算法 | AES-256-CBC |
| 密钥长度 | 256 位（32 字节） |
| 密钥派生 | PBKDF2-SHA256 |
| 迭代次数 | 100,000 |
| Salt 长度 | 16 字节（随机） |
| IV 长度 | 16 字节（随机） |

### 5.3 加密流程

```
1. 生成 16 字节随机 Salt
2. 使用 PBKDF2-SHA256 派生密钥
   - 输入：密码 + Salt
   - 迭代：100,000 次
   - 输出：32 字节密钥
3. 生成 16 字节随机 IV
4. 使用 AES-256-CBC 加密数据
5. 输出格式：
   {
     "salt": "base64(salt)",
     "iv": "base64(iv)",
     "data": "base64(encrypted_data)"
   }
```

### 5.4 解密流程

```
1. 从加密数据中读取 Salt、IV、密文
2. 使用相同的密码 + Salt 通过 PBKDF2 派生密钥
3. 使用 AES-256-CBC 解密数据
4. 返回解密后的明文
```

---

## 6. 关键实现

### 6.1 缩略图处理

**问题**：图片消息的缩略图可能在 encode 时丢失

**解决方案**：
```objc
// 检查 binaryContent 是否为空
if ([message.content isKindOfClass:NSClassFromString(@"WFCCImageMessageContent")]) {
    if (!payload.binaryContent || payload.binaryContent.length == 0) {
        // 手动提取 thumbnail
        if ([message.content respondsToSelector:@selector(thumbnail)]) {
            UIImage *thumbnailImage = [(id)message.content thumbnail];
            if (thumbnailImage) {
                // 转换为 JPEG，压缩质量 0.45
                payload.binaryContent = UIImageJPEGRepresentation(thumbnailImage, 0.45);
                if (payload.binaryContent && payload.binaryContent.length > 0) {
                    // Base64 编码保存
                    payloadDict[@"binaryContent"] = [payload.binaryContent base64EncodedStringWithOptions:0];
                }
            }
        }
    }
}
```

### 6.2 媒体文件处理

**文件命名**：
- 使用 MD5 的前 16 位作为文件ID
- 添加 `media_` 前缀
- 保留原始扩展名
- 示例：`media_abc123def4567890.jpg`、`media_abc123def4567890.mp4`

**去重策略**：
```objc
// 计算 MD5
NSString *md5 = [WFCCBackupCrypto calculateMD5ForFile:localMediaPath];
if (md5 && md5.length >= 16) {
    NSString *fileId = [md5 substringToIndex:16];
    NSString *extension = [localMediaPath pathExtension];
    NSString *fileName = [NSString stringWithFormat:@"media_%@.%@", fileId, extension];

    // relativePath 直接使用文件名（不包含 media/ 子目录）
    NSString *relativePath = fileName;

    // 检查文件是否已存在
    NSString *targetPath = [mediaDir stringByAppendingPathComponent:fileName];
    if (![[NSFileManager defaultManager] fileExistsAtPath:targetPath]) {
        // 不存在才复制
        [[NSFileManager defaultManager] copyItemAtPath:localMediaPath toPath:targetPath error:nil];
    }

    // 保存媒体信息到 payload
    payloadDict[@"localMediaInfo"] = @{
        @"relativePath": relativePath,
        @"fileId": fileId,
        @"fileSize": @(fileSize),
        @"md5": md5
    };

    // 保存文件大小到消息字典
    msgDict[@"mediaFileSize"] = @(fileSize);
}
```

**binaryContent 处理**：
```objc
// 只有非空时才保存 binaryContent（避免保存空数据）
if (payload.binaryContent && payload.binaryContent.length > 0) {
    payloadDict[@"binaryContent"] = [payload.binaryContent base64EncodedStringWithOptions:0];
}
// 否则不保存此字段
```

**参数验证**：
```objc
// 如果提供了密码，必须非空
if (password && password.length == 0) {
    if (error) {
        error(BackupError_InvalidPassword);
    }
    return;
}
```

### 6.3 媒体统计

**问题**：避免统计未实际备份的媒体文件

**解决方案**：
```objc
// 只有在 localMediaInfo 存在时才统计
if (msgDict[@"payload"][@"localMediaInfo"]) {
    convMediaCount++;
    totalMediaSize += [msgDict[@"mediaFileSize"] longLongValue];
}
```

### 6.4 取消清理

**问题**：取消备份后留下不完整的备份目录

**解决方案**：
```objc
// 1. 跟踪当前备份路径
@property (nonatomic, strong) NSString *currentBackupDirectory;

// 2. 备份开始时设置
self.currentBackupDirectory = directoryPath;

// 3. 检测到取消时清理
if (self.isCancelled) {
    [self cleanupIncompleteBackup];
    dispatch_async(dispatch_get_main_queue(), ^{
        error(BackupError_Cancelled);
    });
    return;
}

// 4. 清理方法
- (void)cleanupIncompleteBackup {
    if (self.currentBackupDirectory && self.currentBackupDirectory.length > 0) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory;
        if ([fileManager fileExistsAtPath:self.currentBackupDirectory isDirectory:&isDirectory] && isDirectory) {
            NSError *error;
            BOOL removed = [fileManager removeItemAtPath:self.currentBackupDirectory error:&error];
            if (removed) {
                NSLog(@"[WFCCMessageBackupManager] Cleaned up incomplete backup: %@", self.currentBackupDirectory);
            }
        }
        self.currentBackupDirectory = nil;
    }
}
```

### 6.5 媒体文件恢复

**问题**：恢复时需要将媒体文件从备份目录复制到应用的媒体目录

**恢复流程**：
```objc
// 1. 从备份目录中找到媒体文件
NSDictionary *mediaInfo = payloadDict[@"localMediaInfo"];
NSString *relativePath = mediaInfo[@"relativePath"];  // 文件名，如 "media_xxx.jpg"
NSString *fileId = mediaInfo[@"fileId"];

// relativePath 是文件名，直接拼接到 mediaBaseDir
NSString *backupFilePath = [mediaBaseDir stringByAppendingPathComponent:relativePath];

if ([[NSFileManager defaultManager] fileExistsAtPath:backupFilePath]) {
    // 2. 生成新的媒体文件存储路径（使用 sendbox 目录）
    NSString *mediaDir = [WFCCUtilities getDocumentPathWithComponent:@"sendbox"];
    NSString *extension = [relativePath pathExtension];
    NSString *newFileName = [NSString stringWithFormat:@"%@.%@", fileId, extension];
    NSString *newFilePath = [mediaDir stringByAppendingPathComponent:newFileName];

    // 3. 复制文件到应用的媒体目录
    NSError *copyError;
    [[NSFileManager defaultManager] copyItemAtPath:backupFilePath
                                            toPath:newFilePath
                                             error:&copyError];
    if (!copyError) {
        // 4. 设置正确的 localPath
        if ([payload respondsToSelector:@selector(setLocalMediaPath:)]) {
            [(id)payload setLocalMediaPath:newFilePath];
        }
        NSLog(@"[WFCCMessageBackupManager] Restored media file: %@", newFileName);
    }
}
```

**关键点**：
- **relativePath格式**：直接是文件名（如 `media_abc123.jpg`），不包含路径
- **恢复位置**：复制到 `Documents/sendbox/` 目录
- **新文件名**：使用 `{fileId}.{extension}` 格式（不含 `media_` 前缀）
- **路径设置**：通过 `setLocalMediaPath:` 设置正确的路径
- **错误处理**：复制失败时记录日志，但不中断恢复流程

### 6.6 会话设置恢复

**状态**：⚠️ 尚未实现（TODO标记）

**当前实现**：
```objc
// 更新会话设置（TODO: 实现会话设置的恢复）
```

**说明**：
- metadata.json 中的 settings 字段包含会话的设置信息
- 包括：`isTop`（置顶）、`isSilent`（免打扰）、`draft`（草稿）
- 当前代码中这些设置已从备份文件中读取，但尚未应用到SDK
- 需要调用相应的SDK方法来设置这些属性

### 6.7 文件大小格式化

**实现**：
```objc
- (NSString *)formatFileSize:(long long)bytes {
    if (bytes < 1024) {
        return [NSString stringWithFormat:@"%lld B", bytes];
    } else if (bytes < 1024 * 1024) {
        return [NSString stringWithFormat:@"%.1f KB", bytes / 1024.0];
    } else if (bytes < 1024 * 1024 * 1024) {
        return [NSString stringWithFormat:@"%.1f MB", bytes / (1024.0 * 1024)];
    } else {
        return [NSString stringWithFormat:@"%.2f GB", bytes / (1024.0 * 1024 * 1024)];
    }
}
```

**使用场景**：
- 备份完成后显示媒体文件总大小
- 备份列表显示媒体大小信息
- UI界面友好显示

---

## 7. 错误处理

### 7.1 错误码定义

```objc
typedef NS_ENUM(NSInteger, BackupError) {
    BackupError_NoError = 0,                    // 无错误
    BackupError_FileNotFound = 1001,           // 文件未找到
    BackupError_InvalidFormat = 1002,          // 格式无效
    BackupError_IOError = 1003,                // IO错误
    BackupError_OutOfSpace = 1004,             // 磁盘空间不足
    BackupError_Cancelled = 1005,              // 用户取消
    BackupError_EncryptionFailed = 3001,       // 加密失败
    BackupError_DecryptionFailed = 3002,       // 解密失败
    BackupError_WrongPassword = 3003,          // 密码错误
    BackupError_InvalidPassword = 3004,        // 密码无效
    BackupError_NotEncrypted = 3006,           // 备份未加密
    BackupError_RestoreFailed = 4001           // 恢复失败
};
```

### 7.2 错误处理策略

| 场景 | 处理方式 |
|------|---------|
| 备份时媒体文件复制失败 | 记录警告，跳过该文件，继续备份 |
| 备份时磁盘空间不足 | 立即终止，返回错误 |
| 用户点击取消 | 设置标志，安全退出，清理不完整备份 |
| 解密失败 | 返回错误，不继续恢复 |
| 消息已存在 | 根据 overwriteExisting 参数决定跳过或覆盖 |

### 7.3 错误信息本地化

**实现**：
```objc
- (NSString *)errorMessageForCode:(int)errorCode {
    switch (errorCode) {
        case BackupError_FileNotFound:
            return @"找不到备份文件";
        case BackupError_InvalidFormat:
            return @"备份文件格式不正确";
        case BackupError_IOError:
            return @"文件读写错误";
        case BackupError_OutOfSpace:
            return @"存储空间不足";
        case BackupError_Cancelled:
            return @"操作已取消";
        case BackupError_EncryptionFailed:
            return @"加密失败";
        case BackupError_DecryptionFailed:
            return @"解密失败";
        case BackupError_WrongPassword:
            return @"密码错误";
        case BackupError_RestoreFailed:
            return @"恢复失败";
        default:
            return [NSString stringWithFormat:@"未知错误 (错误码: %d)", errorCode];
    }
}
```

**说明**：
- 将错误码转换为用户友好的中文错误信息
- 在UI层显示给用户
- 未知错误显示错误码便于调试

---

## 8. 性能优化

### 8.1 内存管理

**问题**：大量消息会导致内存峰值

**解决方案**：
```objc
// 使用 @autoreleasepool 包裹循环
for (WFCCConversationInfo *convInfo in backupConversations) {
    @autoreleasepool {
        // 处理会话和消息
        // 自动释放临时对象
    }
}
```

### 8.2 批量处理

**分批获取消息**：
```objc
// 每批处理 100 条消息
while (YES) {
    NSArray<WFCCMessage *> *messages = [[WFCCIMService sharedWFCIMService]
        getMessages:conversation
        contentTypes:nil
        from:fromIndex
        count:-100  // 获取最近100条
        withUser:nil];

    if (messages.count == 0) break;

    // 处理消息
    fromIndex = messages.firstObject.messageId;
}
```

### 8.3 线程安全

**取消标志**：
```objc
@property (atomic, assign) BOOL isCancelled;  // 使用 atomic 确保线程安全
```

**回调线程**：
```objc
// 备份/恢复在后台线程执行
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行操作
    dispatch_async(dispatch_get_main_queue(), ^{
        // 回调在主线程
    });
});
```

---

## 9. UI 设计

### 9.1 会话选择界面

**功能**：
- 支持单选/多选
- 全选/取消全选
- 显示会话信息和消息数量
- 使用 UITableView 内置多选机制

**实现要点**：
```objc
// 全选实现
for (NSInteger i = 0; i < self.conversations.count; i++) {
    NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0];
    [self.tableView selectRowAtIndexPath:indexPath
                                animated:NO
                          scrollPosition:UITableViewScrollPositionNone];
}

// 获取选中项
NSArray<NSIndexPath *> *selectedRows = [self.tableView indexPathsForSelectedRows];
```

### 9.2 备份选项界面

**功能**：
- 显示已选择的会话列表
- 选择是否包含媒体文件
- 开始备份按钮

### 9.3 进度界面

**功能**：
- 显示进度条（0-100%）
- 显示当前状态
- 显示详细信息
- 支持取消操作
- 完成后显示统计信息

**统计显示**：
```
成功备份 3250 条消息
48 个媒体文件 (50.0 MB)
```

### 9.4 备份列表界面

**功能**：
- 显示所有备份
- 显示备份信息：
  - 备份时间
  - 会话数量
  - 消息数量
  - 媒体文件数量和大小（如有）
- 支持删除备份
- 点击备份查看详情

### 9.5 恢复选项界面

**功能**：
- 选择是否覆盖已存在的消息
- 显示备份信息
  - 备份时间
  - 会话数量
  - 消息数量
  - 媒体文件数量和大小（如有）
- 开始恢复按钮

---

## 10. 常量定义

```objc
// 版本和格式
static NSString * const kBackupVersion = @"1";
static NSString * const kBackupFormat = @"directory";
static NSString * const kBackupAppType = @"ios-chat";
static NSString * const kBackupModeMessageWithMedia = @"message_with_media";

// 加密配置
static NSString * const kBackupEncryptionAlgorithm = @"AES-256-CBC";
static NSString * const kBackupKeyDerivation = @"PBKDF2-SHA256";

// 处理参数
static const NSInteger kDefaultMessageBatchSize = -100;  // 每批100条
static const CGFloat kThumbnailCompressionQuality = 0.45;  // 缩略图压缩质量
```

---

## 11. 测试计划

### 11.1 功能测试

**基础备份**：
- [ ] 备份单个会话
- [ ] 备份多个会话
- [ ] 备份所有会话
- [ ] 验证目录结构正确

**媒体文件**：
- [ ] 备份包含图片的会话
- [ ] 备份包含视频的会话
- [ ] 验证缩略图正确保存
- [ ] 验证媒体文件正确复制
- [ ] 验证 MD5 去重
- [ ] 验证统计信息准确

**加密功能**：
- [ ] 创建加密备份
- [ ] 使用正确密码恢复
- [ ] 使用错误密码恢复
- [ ] 创建未加密备份

**取消操作**：
- [ ] 备份过程中取消
- [ ] 验证不完整备份被删除
- [ ] 验证备份列表不显示不完整备份

**恢复功能**：
- [ ] 恢复加密备份
- [ ] 恢复未加密备份
- [ ] 验证消息正确恢复
- [ ] 验证媒体文件正确恢复
- [ ] 验证缩略图正确显示
- [ ] 测试覆盖已存在消息
- [ ] 测试跳过已存在消息

### 11.2 性能测试

**大规模数据**：
- [ ] 100个会话，每个1000条消息
- [ ] 验证内存稳定
- [ ] 验证进度正常更新
- [ ] 记录备份时间
- [ ] 记录恢复时间

**大量媒体**：
- [ ] 1000个媒体文件
- [ ] 总大小500MB+
- [ ] 验证备份时间可接受
- [ ] 验证恢复时间可接受

### 11.3 边界测试

- [ ] 空数据库（无会话）
- [ ] 空会话（无消息）
- [ ] 超长消息内容
- [ ] 特殊字符处理
- [ ] 磁盘空间不足

---

## 12. 安全考虑

### 12.1 数据安全

1. **密码管理**
   - 密码不以明文形式存储
   - 使用 PBKDF2 增强密码强度
   - 支持密码提示（不包含实际密码）

2. **加密保护**
   - 消息内容使用 AES-256-CBC 加密
   - 密钥派生使用 100,000 次迭代
   - Salt 和 IV 随机生成

3. **数据分离**
   - 敏感数据加密（消息内容）
   - 非敏感数据明文（元数据、媒体）
   - 便于查看备份基本信息

### 12.2 文件安全

1. **路径验证**
   - 验证文件路径防止路径遍历
   - 使用 URL 编码处理特殊字符

2. **完整性校验**
   - 媒体文件使用 MD5 校验
   - JSON 格式验证
   - 加密数据完整性检查

---

## 13. 最佳实践

### 13.1 备份建议

1. **定期备份**
   - 建议每周至少备份一次
   - 重要对话后立即备份

2. **密码管理**
   - 使用强密码
   - 记住密码提示
   - 不要丢失密码

3. **存储管理**
   - 定期清理旧备份
   - 保留多个备份副本
   - 考虑导出到 iCloud 或电脑

### 13.2 使用建议

1. **备份前**
   - 检查可用存储空间
   - 确保设备电量充足
   - 关闭不必要的应用

2. **恢复前**
   - 验证备份完整性
   - 检查密码是否正确
   - 确保存储空间充足

3. **异常处理**
   - 备份失败后检查错误信息
   - 恢复失败不要重复尝试
   - 必要时联系技术支持

---

## 14. 未来扩展

### 14.1 可能的改进

1. **增量备份**
   - 只备份新增消息
   - 减少备份时间和空间

2. **压缩优化**
   - 使用 zip 格式打包
   - 压缩媒体文件

3. **云端备份**
   - 支持 iCloud Drive
   - 支持自定义服务器

4. **选择性恢复**
   - 选择某些会话恢复
   - 按时间范围恢复

5. **备份合并**
   - 合并多个备份
   - 去重消息

---

## 15. 总结

本设计文档描述了基于目录结构的消息备份恢复系统的完整设计。系统具有以下特点：

✅ **结构清晰**：目录结构，每个会话独立
✅ **安全性好**：支持加密，可选密码保护
✅ **灵活性强**：支持选择性备份会话
✅ **用户友好**：进度反馈，统计信息，取消清理
✅ **性能优化**：内存管理，批量处理，线程安全
✅ **功能完整**：备份、恢复、加密、统计、列表管理

系统已实现并可投入使用，建议进行充分的测试验证。

---

**文档版本**: 2.0
**最后更新**: 2025-01-10
**维护者**: WildFireChat Team
