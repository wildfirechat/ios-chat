# 消息备份加密方案

## 文档版本

| 版本 | 日期 | 说明 |
|------|------|------|
| 1.0 | 2025-01-09 | 初始版本 |

---

## 1. 加密需求分析

### 1.1 安全目标
- ✅ 防止备份文件被未授权访问
- ✅ 保护敏感聊天内容（文本、图片、文件等）
- ✅ 防止备份文件被篡改
- ✅ 支持密码验证和错误提示

### 1.2 加密场景

| 场景 | 需求 | 方案 |
|------|------|------|
| 个人隐私保护 | 防止他人查看备份 | 密码加密 |
| 设备丢失 | 设备丢失后数据不泄露 | 强密码 + PBKDF2 |
| 云存储 | 上传到云端时的安全 | 加密后上传 |
| 合规要求 | 满足数据保护法规 | 符合加密标准 |

### 1.3 加密范围选项

#### 选项 1：全量加密（推荐）⭐
```json
{
  "version": "1.0",
  "encryption": {
    "algorithm": "AES-256-GCM",
    "keyDerivation": "PBKDF2",
    "iterations": 100000,
    "salt": "base64_encoded_salt"
  },
  "encryptedData": "base64_encoded_all_content",
  "authTag": "base64_auth_tag"
}
```

**优势**：
- ✅ 安全性最高
- ✅ 实现简单
- ✅ 所有数据都被保护

**劣势**：
- ❌ 无法预览备份内容
- ❌ 必须解密才能读取任何信息

#### 选项 2：部分加密
```json
{
  "version": "1.0",
  "encryption": {
    "algorithm": "AES-256-GCM",
    "encryptedFields": ["content", "localContent", "searchableContent"]
  },
  "meta": {
    "backupTime": "2025-01-09",
    "totalConversations": 5
    // 元数据不加密，可以预览
  },
  "conversations": [
    {
      "type": 1,
      "target": "user123",
      // 会话信息不加密
      "messages": [
        {
          "messageUid": 67890,
          "fromUser": "user123",
          // 消息元数据不加密
          "payload": {
            "contentType": 1,
            "content": "encrypted_base64_data",  // 加密字段
            "searchableContent": "encrypted_base64_data"  // 加密字段
          }
        }
      ]
    }
  ]
}
```

**优势**：
- ✅ 可以预览备份结构
- ✅ 可以看到会话列表和消息数量
- ✅ 性能稍好（只加密敏感字段）

**劣势**：
- ❌ 仍然泄露元数据（谁和谁聊天、何时聊天）
- ❌ 实现复杂

#### 选项 3：混合加密（推荐）⭐⭐
```json
{
  "version": "1.0",
  "encryption": {
    "algorithm": "AES-256-GCM",
    "mode": "hybrid"
  },
  "publicInfo": {
    "backupTime": "2025-01-09T10:30:00Z",
    "totalConversations": 5,
    "totalMessages": 1234,
    "encryptionHint": "Encrypted with password",
    // 可以添加密码提示
    "passwordHint": "我的生日是1988年5月20日"
  },
  "encryptedData": {
    "salt": "base64_salt",
    "iv": "base64_iv",
    "authTag": "base64_auth_tag",
    "data": "base64_encrypted_content"
  }
}
```

**优势**：
- ✅ 平衡安全性和可用性
- ✅ 可以显示基本信息
- ✅ 支持密码提示
- ✅ 验证密码时无需解密全部数据

---

## 2. 加密技术方案

### 2.1 加密算法选择

**已实现方案**：AES-256-CBC + PKCS7Padding

由于 iOS CommonCrypto 对 GCM 模式支持限制，实际实现采用 CBC 模式：
- ✅ AES-256-CBC 加密
- ✅ PBKDF2-SHA256 密钥派生
- ✅ PKCS7 填充
- ✅ 每次加密使用不同的 IV

| 组件 | 选择 | 理由 |
|------|------|------|
| 对称加密 | **AES-256-CBC** | 行业标准，iOS 原生支持 |
| 密钥派生 | **PBKDF2-SHA256** | 防止暴力破解，可调节迭代次数 |
| 密钥长度 | 256 位 | AES-256 标准 |
| 迭代次数 | 100,000+ | 平衡安全性和性能（iOS 推荐） |
| Salt 长度 | 128 位 | 防止彩虹表攻击 |
| IV 长度 | 16 字节（CBC 标准） | 每次加密不同 |
| 填充模式 | PKCS7 | CBC 标准填充 |

### 2.2 加密流程

```
用户输入密码
    ↓
生成随机 Salt (128位)
    ↓
PBKDF2 派生密钥 (100,000 次迭代)
    ↓
生成随机 IV (16字节)
    ↓
AES-256-CBC 加密数据（PKCS7 填充）
    ↓
输出：Salt + IV + Ciphertext
```

### 2.3 核心代码实现

```objc
// WFCCBackupCrypto.h
#import <Foundation/Foundation.h>
#import <CommonCrypto/CommonCrypto.h>

NS_ASSUME_NONNULL_BEGIN

@interface WFCCBackupCrypto : NSObject

/**
 * 从密码派生加密密钥
 * @param password 用户密码
 * @param salt 盐值（随机生成）
 * @param iterations PBKDF2 迭代次数
 * @return 派生的密钥数据（32字节，用于 AES-256）
 */
+ (NSData *)deriveKeyFromPassword:(NSString *)password
                            salt:(NSData *)salt
                      iterations:(NSUInteger)iterations;

/**
 * 加密数据
 * @param data 明文数据
 * @param password 用户密码
 * @param error 错误输出
 * @return 加密结果字典，包含：
 *         - salt: Base64 编码的盐值
 *         - iv: Base64 编码的 IV
 *         - data: Base64 编码的密文
 */
+ (nullable NSDictionary *)encryptData:(NSData *)data
                            password:(NSString *)password
                               error:(NSError **)error;

/**
 * 解密数据
 * @param encryptedData 加密数据字典（包含 salt, iv, data, authTag）
 * @param password 用户密码
 * @param error 错误输出
 * @return 解密后的明文数据，解密失败返回 nil
 */
+ (nullable NSData *)decryptData:(NSDictionary *)encryptedData
                       password:(NSString *)password
                          error:(NSError **)error;

/**
 * 验证密码（不解密全部数据，只验证密钥是否正确）
 * @param encryptedData 加密数据字典
 * @param password 用户密码
 * @return 密码是否正确
 */
+ (BOOL)verifyPassword:(NSDictionary *)encryptedData
              password:(NSString *)password;


@end

NS_ASSUME_NONNULL_END
```

### 2.4 实现代码

**注意**：以下是文档示例，实际实现请参考 `wfclient/WFChatClient/Backup/WFCCBackupCrypto.m`

```objc
// WFCCBackupCrypto.m
#import "WFCCBackupCrypto.h"

@implementation WFCCBackupCrypto

#pragma mark - Constants

static const NSUInteger kKeySize = kCCKeySizeAES256;           // 32 bytes
static const NSUInteger kSaltSize = 16;                       // 128 bits
static const NSUInteger kIVSize = kCCBlockSizeAES128;         // 16 bytes for CBC
static const NSUInteger kPBKDF2Iterations = 100000;           // 推荐值

#pragma mark - Key Derivation

+ (NSData *)deriveKeyFromPassword:(NSString *)password
                            salt:(NSData *)salt
                      iterations:(NSUInteger)iterations {

    // 将密码转换为 UTF8 数据
    NSData *passwordData = [password dataUsingEncoding:NSUTF8StringEncoding];

    // 分配密钥存储空间
    NSMutableData *derivedKey = [NSMutableData dataWithLength:kKeySize];

    // PBKDF2 派生
    int result = CCKeyDerivationPBKDF(
        kCCPBKDF2,                        // 算法
        passwordData.bytes,                // 密码
        passwordData.length,               // 密码长度
        salt.bytes,                        // 盐
        salt.length,                       // 盐长度
        kCCPRFHmacAlgSHA256,               // 伪随机函数
        iterations,                        // 迭代次数
        derivedKey.mutableBytes,           // 输出密钥
        derivedKey.length                  // 密钥长度
    );

    if (result != kCCSuccess) {
        NSLog(@"Key derivation failed: %d", result);
        return nil;
    }

    return [derivedKey copy];
}

#pragma mark - Encryption

+ (NSDictionary *)encryptData:(NSData *)data
                     password:(NSString *)password
                        error:(NSError **)error {

    // 1. 生成随机 Salt
    NSData *salt = [self generateRandomDataOfSize:kSaltSize];
    if (!salt) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:1001
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to generate salt"}];
        }
        return nil;
    }

    // 2. 派生密钥
    NSData *key = [self deriveKeyFromPassword:password
                                        salt:salt
                                  iterations:kPBKDF2Iterations];
    if (!key) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:1002
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to derive key"}];
        }
        return nil;
    }

    // 3. 生成随机 IV
    NSData *iv = [self generateRandomDataOfSize:kIVSize];
    if (!iv) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:1003
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to generate IV"}];
        }
        return nil;
    }

    // 4. 使用 AES-256-CBC 加密
    size_t bufferSize = data.length + kCCBlockSizeAES128;
    NSMutableData *encryptedData = [NSMutableData dataWithLength:bufferSize];

    size_t dataOutMoved = 0;
    CCCryptorStatus status = CCCrypt(
        kCCEncrypt,                       // 加密
        kCCAlgorithmAES,                  // AES 算法
        kCCOptionPKCS7Padding,            // PKCS7 填充
        key.bytes,                        // 密钥
        key.length,                       // 密钥长度
        iv.bytes,                         // IV
        data.bytes,                       // 输入数据
        data.length,                      // 输入长度
        encryptedData.mutableBytes,       // 输出缓冲区
        bufferSize,                       // 输出缓冲区大小
        &dataOutMoved                     // 实际输出长度
    );

    if (status != kCCSuccess) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:1004
                                     userInfo:@{NSLocalizedDescriptionKey: @"Encryption failed"}];
        }
        return nil;
    }

    encryptedData.length = dataOutMoved;

    // 5. 返回加密结果
    return @{
        @"salt": [salt base64EncodedStringWithOptions:0],
        @"iv": [iv base64EncodedStringWithOptions:0],
        @"data": [encryptedData base64EncodedStringWithOptions:0],
        @"iterations": @(kPBKDF2Iterations)
    };
}

#pragma mark - Decryption

+ (NSData *)decryptData:(NSDictionary *)encryptedData
               password:(NSString *)password
                  error:(NSError **)error {

    // 1. 提取加密参数
    NSData *salt = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"salt"] options:0];
    NSData *iv = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"iv"] options:0];
    NSData *ciphertext = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"data"] options:0];
    NSUInteger iterations = [encryptedData[@"iterations"] unsignedIntegerValue];

    if (!salt || !iv || !ciphertext) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:2001
                                     userInfo:@{NSLocalizedDescriptionKey: @"Invalid encrypted data format"}];
        }
        return nil;
    }

    // 2. 派生密钥
    NSData *key = [self deriveKeyFromPassword:password
                                        salt:salt
                                  iterations:iterations];
    if (!key) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:2002
                                     userInfo:@{NSLocalizedDescriptionKey: @"Failed to derive key"}];
        }
        return nil;
    }

    // 3. 使用 AES-256-CBC 解密
    size_t bufferSize = ciphertext.length + kCCBlockSizeAES128;
    NSMutableData *decryptedData = [NSMutableData dataWithLength:bufferSize];

    size_t dataOutMoved = 0;
    CCCryptorStatus status = CCCrypt(
        kCCDecrypt,                       // 解密
        kCCAlgorithmAES,                  // AES 算法
        kCCOptionPKCS7Padding,            // PKCS7 填充
        key.bytes,                        // 密钥
        key.length,                       // 密钥长度
        iv.bytes,                         // IV
        ciphertext.bytes,                 // 输入数据
        ciphertext.length,                // 输入长度
        decryptedData.mutableBytes,       // 输出缓冲区
        bufferSize,                       // 输出缓冲区大小
        &dataOutMoved                     // 实际输出长度
    );

    if (status != kCCSuccess) {
        if (error) {
            *error = [NSError errorWithDomain:@"WFCCBackupCryptoError"
                                         code:2003
                                     userInfo:@{NSLocalizedDescriptionKey: @"Decryption failed"}];
        }
        return nil;
    }

    decryptedData.length = dataOutMoved;

    return [decryptedData copy];
}

#pragma mark - Password Verification

+ (BOOL)verifyPassword:(NSDictionary *)encryptedData
              password:(NSString *)password {

    // 尝试解密来验证密码
    NSData *salt = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"salt"] options:0];
    NSData *iv = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"iv"] options:0];
    NSData *ciphertext = [[NSData alloc] initWithBase64EncodedString:encryptedData[@"data"] options:0];
    NSUInteger iterations = [encryptedData[@"iterations"] unsignedIntegerValue];

    if (!salt || !iv || !ciphertext) {
        return NO;
    }

    // 派生密钥
    NSData *key = [self deriveKeyFromPassword:password
                                        salt:salt
                                  iterations:iterations];
    if (!key) {
        return NO;
    }

    // 尝试解密（验证密钥）
    size_t bufferSize = ciphertext.length + kCCBlockSizeAES128;
    NSMutableData *decryptedData = [NSMutableData dataWithLength:bufferSize];

    size_t dataOutMoved = 0;
    CCCryptorStatus status = CCCrypt(
        kCCDecrypt,
        kCCAlgorithmAES,
        kCCOptionPKCS7Padding,
        key.bytes,
        key.length,
        iv.bytes,
        ciphertext.bytes,
        ciphertext.length,
        decryptedData.mutableBytes,
        bufferSize,
        &dataOutMoved
    );

    return (status == kCCSuccess);
}

#pragma mark - Helper Methods

+ (NSData *)generateRandomDataOfSize:(NSUInteger)size {
    NSMutableData *data = [NSMutableData dataWithLength:size];
    int result = SecRandomCopyBytes(kSecRandomDefault, size, data.mutableBytes);
    return (result == errSecSuccess) ? [data copy] : nil;
}

@end
```

---

## 3. 更新的备份接口

### 3.1 接口定义

```objc
// WFCCMessageBackupManager.h
@interface WFCCMessageBackupManager : NSObject

#pragma mark - 创建加密备份

/**
 * 创建加密备份
 * @param filePath 备份文件路径
 * @param password 加密密码（不能为空）
 * @param passwordHint 密码提示（可选，用于帮助记忆）
 * @param includeMedia 是否包含媒体文件
 * @param progress 进度回调
 * @param success 成功回调
 * @param error 失败回调
 */
- (void)createEncryptedBackup:(NSString *)filePath
                     password:(NSString *)password
               passwordHint:(nullable NSString *)passwordHint
                includeMedia:(BOOL)includeMedia
                   progress:(nullable void(^)(NSProgress *progress))progress
                    success:(void(^)(NSString *backupPath))success
                      error:(void(^)(int errorCode))error;

/**
 * 创建未加密备份
 * @param filePath 备份文件路径
 * @param includeMedia 是否包含媒体文件
 * @param progress 进度回调
 * @param success 成功回调
 * @param error 失败回调
 */
- (void)createUnencryptedBackup:(NSString *)filePath
                  includeMedia:(BOOL)includeMedia
                     progress:(nullable void(^)(NSProgress *progress))progress
                      success:(void(^)(NSString *backupPath))success
                        error:(void(^)(int errorCode))error;

#pragma mark - 恢复加密备份

/**
 * 恢复加密备份
 * @param filePath 备份文件路径
 * @param password 解密密码
 * @param overwriteExisting 是否覆盖已存在的消息
 * @param mediaBasePath 媒体文件存放路径
 * @param progress 进度回调
 * @param success 成功回调
 * @param error 失败回调（包括密码错误）
 */
- (void)restoreEncryptedBackup:(NSString *)filePath
                      password:(NSString *)password
            overwriteExisting:(BOOL)overwriteExisting
                mediaBasePath:(nullable NSString *)mediaBasePath
                     progress:(nullable void(^)(NSProgress *progress))progress
                      success:(void(^)(int restoredMessageCount, int restoredMediaCount))success
                        error:(void(^)(int errorCode))error;

/**
 * 恢复未加密备份
 * @param filePath 备份文件路径
 * @param overwriteExisting 是否覆盖已存在的消息
 * @param mediaBasePath 媒体文件存放路径
 * @param progress 进度回调
 * @param success 成功回调
 * @param error 失败回调
 */
- (void)restoreUnencryptedBackup:(NSString *)filePath
              overwriteExisting:(BOOL)overwriteExisting
                  mediaBasePath:(nullable NSString *)mediaBasePath
                       progress:(nullable void(^)(NSProgress *progress))progress
                        success:(void(^)(int restoredMessageCount, int restoredMediaCount))success
                          error:(void(^)(int errorCode))error;

#pragma mark - 密码相关

/**
 * 验证备份密码
 * @param filePath 备份文件路径
 * @param password 密码
 * @return 密码是否正确
 */
- (BOOL)verifyBackupPassword:(NSString *)filePath
                    password:(NSString *)password;

/**
 * 修改备份密码
 * @param filePath 原备份文件路径
 * @param oldPassword 旧密码
 * @param newPassword 新密码
 * @param newHint 新密码提示
 * @param success 成功回调
 * @param error 失败回调
 */
- (void)changeBackupPassword:(NSString *)filePath
                 oldPassword:(NSString *)oldPassword
                 newPassword:(NSString *)newPassword
                  newHint:(nullable NSString *)newHint
                   success:(void(^)(void))success
                     error:(void(^)(int errorCode))error;

/**
 * 获取备份密码提示
 * @param filePath 备份文件路径
 * @return 密码提示，如果没有返回 nil
 */
- (nullable NSString *)getBackupPasswordHint:(NSString *)filePath;

#pragma mark - 备份信息

/**
 * 获取加密备份的基本信息（无需密码）
 * @param filePath 备份文件路径
 * @return 备份信息字典
 */
- (nullable NSDictionary *)getEncryptedBackupInfo:(NSString *)filePath;

@end
```

### 3.2 实现代码

```objc
// WFCCMessageBackupManager.m
#import "WFCCMessageBackupManager.h"
#import "WFCCBackupCrypto.h"

@implementation WFCCMessageBackupManager

- (void)createEncryptedBackup:(NSString *)filePath
                     password:(NSString *)password
               passwordHint:(NSString *)passwordHint
                includeMedia:(BOOL)includeMedia
                   progress:(void(^)(NSProgress *))progress
                    success:(void(^)(NSString *))success
                      error:(void(^)(int))error {

    // 1. 验证密码
    if (!password || password.length == 0) {
        if (error) {
            error(BackupError_InvalidPassword);
        }
        return;
    }

    // 2. 在后台线程执行
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 4. 生成未加密的备份数据
        NSMutableDictionary *backupData = [NSMutableDictionary dictionary];
        backupData[@"version"] = BackupVersion;
        backupData[@"backupTime"] = [[NSDate date] ISO8601String];
        backupData[@"userId"] = [[WFCCIMService sharedWFCIMService] currentUserId];
        backupData[@"backupMode"] = includeMedia ? BackupMode_MessageWithMedia : BackupMode_MessageOnly;

        // 收集会话和消息数据
        NSMutableArray *conversationsArray = [NSMutableArray array];
        NSArray *conversations = [[WFCCIMService sharedWFCIMService] getConversationInfos:@[@1, @2] lines:@[@0]];

        NSProgress *collectProgress = [NSProgress progressWithTotalUnitCount:conversations.count];

        for (WFCCConversationInfo *convInfo in conversations) {
            @autoreleasepool {
                NSDictionary *convDict = [self encodeConversationInfo:convInfo];
                WFCCConversation *conversation = convInfo.conversation;

                NSArray *messages = [[WFCCIMService sharedWFCIMService] getMessages:conversation
                                                                    contentTypes:nil
                                                                            from:0
                                                                           count:-1
                                                                        withUser:nil];
                NSMutableArray *messagesArray = [NSMutableArray array];

                for (WFCCMessage *message in messages) {
                    NSDictionary *msgDict = [self encodeMessage:message
                                                   includeMedia:includeMedia];
                    [messagesArray addObject:msgDict];
                }

                convDict[@"messages"] = messagesArray;
                [conversationsArray addObject:convDict];

                collectProgress.completedUnitCount++;
                if (progress) {
                    dispatch_async(dispatch_get_main_queue(), ^{
                        progress(collectProgress);
                    });
                }
            }
        }

        backupData[@"conversations"] = conversationsArray;

        // 5. 生成统计信息
        NSDictionary *stats = [self generateStatisticsForBackup:backupData];
        backupData[@"statistics"] = stats;

        // 6. 序列化为 JSON
        NSError *jsonError;
        NSData *jsonData = [NSJSONSerialization dataWithJSONObject:backupData
                                                           options:0
                                                             error:&jsonError];
        if (jsonError) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_InvalidFormat);
            });
            return;
        }

        // 7. 加密数据
        NSError *cryptoError;
        NSDictionary *encryptedResult = [WFCCBackupCrypto encryptData:jsonData
                                                            password:password
                                                               error:&cryptoError];
        if (!encryptedResult) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_EncryptionFailed);
            });
            return;
        }

        // 8. 构建最终备份文件（包含公钥信息 + 加密数据）
        NSMutableDictionary *finalBackup = [NSMutableDictionary dictionary];

        finalBackup[@"version"] = BackupVersion;
        finalBackup[@"encryption"] = @{
            @"enabled": @YES,
            @"algorithm": @"AES-256-GCM",
            @"keyDerivation": @"PBKDF2-SHA256"
        };

        // 公开信息（不加密）
        finalBackup[@"publicInfo"] = @{
            @"backupTime": [[NSDate date] ISO8601String],
            @"userId": [[WFCCIMService sharedWFCIMService] currentUserId],
            @"totalConversations": @(conversationsArray.count),
            @"totalMessages": stats[@"totalMessages"],
            @"backupSize": @(jsonData.length),
            @"passwordHint": passwordHint ?: @"",
            @"encryptionHint": @"This backup is encrypted with a password"
        };

        // 加密数据
        finalBackup[@"encryptedData"] = encryptedResult;

        // 9. 保存到文件
        NSData *finalJsonData = [NSJSONSerialization dataWithJSONObject:finalBackup
                                                                options:NSJSONWritingPrettyPrinted
                                                                  error:&jsonError];
        if (jsonError) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_IOError);
            });
            return;
        }

        BOOL writeSuccess = [finalJsonData writeToFile:filePath atomically:YES];
        if (!writeSuccess) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_IOError);
            });
            return;
        }

        // 10. 完成
        dispatch_async(dispatch_get_main_queue(), ^{
            success(filePath);
        });
    });
}

- (void)restoreEncryptedBackup:(NSString *)filePath
                      password:(NSString *)password
            overwriteExisting:(BOOL)overwriteExisting
                mediaBasePath:(NSString *)mediaBasePath
                     progress:(void(^)(NSProgress *))progress
                      success:(void(^)(int, int))success
                        error:(void(^)(int))error {

    // 1. 读取备份文件
    NSData *jsonData = [NSData dataWithContentsOfFile:filePath];
    if (!jsonData) {
        error(BackupError_FileNotFound);
        return;
    }

    NSError *jsonError;
    NSDictionary *backupFile = [NSJSONSerialization JSONObjectWithData:jsonData
                                                              options:0
                                                                error:&jsonError];
    if (!backupFile || jsonError) {
        error(BackupError_InvalidFormat);
        return;
    }

    // 2. 验证是否是加密备份
    if (![backupFile[@"encryption"][@"enabled"] boolValue]) {
        error(BackupError_NotEncrypted);  // 这不是加密备份
        return;
    }

    // 3. 验证密码
    NSDictionary *encryptedData = backupFile[@"encryptedData"];
    if (![WFCCBackupCrypto verifyPassword:encryptedData password:password]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            error(BackupError_WrongPassword);
        });
        return;
    }

    // 4. 在后台线程解密
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *cryptoError;
        NSData *decryptedData = [WFCCBackupCrypto decryptData:encryptedData
                                                     password:password
                                                        error:&cryptoError];
        if (!decryptedData) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_DecryptionFailed);
            });
            return;
        }

        // 5. 解析解密后的备份数据
        NSError *parseError;
        NSDictionary *backupData = [NSJSONSerialization JSONObjectWithData:decryptedData
                                                                   options:0
                                                                     error:&parseError];
        if (!backupData || parseError) {
            dispatch_async(dispatch_get_main_queue(), ^{
                error(BackupError_InvalidFormat);
            });
            return;
        }

        // 6. 执行恢复（复用原有的恢复逻辑）
        [self performRestore:backupData
          overwriteExisting:overwriteExisting
              mediaBasePath:mediaBasePath
                   progress:progress
                    success:success
                      error:error];
    });
}

- (BOOL)verifyBackupPassword:(NSString *)filePath
                    password:(NSString *)password {

    NSData *jsonData = [NSData dataWithContentsOfFile:filePath];
    if (!jsonData) return NO;

    NSError *error;
    NSDictionary *backupFile = [NSJSONSerialization JSONObjectWithData:jsonData
                                                              options:0
                                                                error:&error];
    if (!backupFile || error) return NO;

    if (![backupFile[@"encryption"][@"enabled"] boolValue]) {
        return YES;  // 未加密备份不需要密码
    }

    NSDictionary *encryptedData = backupFile[@"encryptedData"];
    return [WFCCBackupCrypto verifyPassword:encryptedData password:password];
}

- (NSString *)getBackupPasswordHint:(NSString *)filePath {

    NSData *jsonData = [NSData dataWithContentsOfFile:filePath];
    if (!jsonData) return nil;

    NSError *error;
    NSDictionary *backupFile = [NSJSONSerialization JSONObjectWithData:jsonData
                                                              options:0
                                                                error:&error];
    if (!backupFile || error) return nil;

    NSString *hint = backupFile[@"publicInfo"][@"passwordHint"];
    return hint.length > 0 ? hint : nil;
}

- (NSDictionary *)getEncryptedBackupInfo:(NSString *)filePath {

    NSData *jsonData = [NSData dataWithContentsOfFile:filePath];
    if (!jsonData) return nil;

    NSError *error;
    NSDictionary *backupFile = [NSJSONSerialization JSONObjectWithData:jsonData
                                                              options:0
                                                                error:&error];
    if (!backupFile || error) return nil;

    // 返回公开信息（无需解密）
    return @{
        @"version": backupFile[@"version"],
        @"isEncrypted": @([backupFile[@"encryption"][@"enabled"] boolValue]),
        @"backupTime": backupFile[@"publicInfo"][@"backupTime"],
        @"totalConversations": backupFile[@"publicInfo"][@"totalConversations"],
        @"totalMessages": backupFile[@"publicInfo"][@"totalMessages"],
        @"hasPasswordHint": @([backupFile[@"publicInfo"][@"passwordHint"] length] > 0),
        @"algorithm": backupFile[@"encryption"][@"algorithm"]
    };
}

@end
```

---

## 4. 加密后的数据格式

### 4.1 完整格式示例

```json
{
  "version": "1.0",
  "encryption": {
    "enabled": true,
    "algorithm": "AES-256-CBC",
    "keyDerivation": "PBKDF2-SHA256"
  },
  "publicInfo": {
    "backupTime": "2025-01-09T10:30:00Z",
    "userId": "user123",
    "totalConversations": 5,
    "totalMessages": 1234,
    "backupSize": 5242880,
    "passwordHint": "我的生日是1988年5月20日",
    "encryptionHint": "This backup is encrypted with a password"
  },
  "encryptedData": {
    "salt": "YWJjZGVmZ2hpams=",  // Base64 编码的随机盐
    "iv": "MTIzNDU2Nzg5MDEyMzQ1Njc4OTA=",  // Base64 编码的 IV
    "iterations": 100000,
    "data": "ZW5jcnlwdGVkX2Jhc2U2NF9kYXRhX2hlcmUuLi4="  // Base64 编码的密文
  }
}
```

### 4.2 格式说明

| 字段 | 说明 | 是否加密 |
|------|------|---------|
| version | 备份格式版本 | ❌ |
| encryption | 加密算法信息 | ❌ |
| publicInfo | 公开信息（元数据） | ❌ |
| encryptedData.salt | PBKDF2 盐值 | ❌（但与密钥绑定） |
| encryptedData.iv | AES 初始化向量 | ❌（但每次不同） |
| encryptedData.iterations | PBKDF2 迭代次数 | ❌ |
| encryptedData.data | 加密后的备份数据 | ✅ |

---

## 5. 错误码定义

```objc
// WFCCBackupEncryptionErrors.h
typedef NS_ENUM(NSInteger, BackupEncryptionError) {
    BackupError_NoError = 0,

    // 加密相关
    BackupError_EncryptionFailed = 3001,           // 加密失败
    BackupError_DecryptionFailed = 3002,           // 解密失败
    BackupError_WrongPassword = 3003,              // 密码错误
    BackupError_InvalidPassword = 3004,            // 密码无效（为空或太短）
    BackupError_WeakPassword = 3005,               // 密码太弱（警告）
    BackupError_NotEncrypted = 3006,               // 备份未加密（但使用了加密接口）
    BackupError_AlreadyEncrypted = 3007,           // 备份已加密
    BackupError_KeyDerivationFailed = 3008,        // 密钥派生失败
    BackupError_InvalidEncryptedFormat = 3009,     // 加密数据格式无效
};
```

---

## 6. UI 交互示例

### 6.1 创建加密备份

```objc
// 显示备份选项界面
UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"创建备份"
                                                               message:@"请选择备份选项"
                                                        preferredStyle:UIAlertControllerStyleActionSheet];

// 仅消息备份（不加密）
[alert addAction:[UIAlertAction actionWithTitle:@"仅消息备份（不加密）"
                                          style:UIAlertActionStyleDefault
                                        handler:^(UIAlertAction *action) {
    [backupManager createUnencryptedBackup:backupPath
                            includeMedia:NO
                               progress:^(NSProgress *progress) {
        // 更新进度
    }
                                success:^(NSString *path) {
        NSLog(@"备份成功");
    }
                                  error:^(int code) {
        NSLog(@"备份失败");
    }];
}]];

// 完整备份（不加密）
[alert addAction:[UIAlertAction actionWithTitle:@"完整备份（不加密）"
                                          style:UIAlertActionStyleDefault
                                        handler:^(UIAlertAction *action) {
    [backupManager createUnencryptedBackup:backupPath
                            includeMedia:YES
                               progress:^(NSProgress *progress) {
        // 更新进度
    }
                                success:^(NSString *path) {
        NSLog(@"备份成功");
    }
                                  error:^(int code) {
        NSLog(@"备份失败");
    }];
}]];

// 加密备份
[alert addAction:[UIAlertAction actionWithTitle:@"加密备份（推荐）"
                                          style:UIAlertActionStyleDefault
                                        handler:^(UIAlertAction *action) {
    // 显示密码输入界面
    [self showPasswordInputDialog:^(NSString *password, NSString *hint) {
        [self performEncryptedBackup:password hint:hint];
    }];
}]];

[self presentViewController:alert animated:YES completion:nil];
```

### 6.2 恢复加密备份

```objc
// 1. 尝试恢复（自动检测是否加密）
[backupManager restoreFromBackup:filePath
              overwriteExisting:NO
                  mediaBasePath:nil
                       progress:^(NSProgress *progress) {
    // 更新进度
}
                        success:^(int msgCount, int mediaCount) {
    // 恢复成功
    NSLog(@"恢复成功：%d 条消息", msgCount);
}
                          error:^(int errorCode) {
    if (errorCode == BackupError_WrongPassword) {
        // 显示密码输入界面
        [self showPasswordInputDialog:^(NSString *password) {
            // 重新尝试恢复
            [backupManager restoreEncryptedBackup:filePath
                                        password:password
                              overwriteExisting:NO
                                  mediaBasePath:nil
                                       progress:^(NSProgress *progress) {
                // 更新进度
            }
                                        success:^(int msgCount, int mediaCount) {
                NSLog(@"恢复成功：%d 条消息", msgCount);
            }
                                          error:^(int errorCode) {
                if (errorCode == BackupError_WrongPassword) {
                    // 再次密码错误
                    [self showAlert:@"密码错误，请重试"];
                } else {
                    [self showAlert:@"恢复失败"];
                }
            }];
        }];
    } else {
        // 其他错误
        [self showAlert:@"恢复失败"];
    }
}];
```

### 6.3 显示密码提示

```objc
// 如果用户忘记密码，显示密码提示
NSString *hint = [backupManager getBackupPasswordHint:filePath];
if (hint) {
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"密码提示"
                                                                   message:hint
                                                            preferredStyle:UIAlertControllerStyleAlert];

    [alert addAction:[UIAlertAction actionWithTitle:@"知道了"
                                              style:UIAlertActionStyleDefault
                                            handler:nil]];

    [self presentViewController:alert animated:YES completion:nil];
} else {
    [self showAlert:@"未设置密码提示"];
}
```

---

## 7. 安全最佳实践

### 7.1 密码提示

✅ **好的提示**：
- "我的生日是1988年5月20日"
- "我最喜欢的城市是巴黎"
- "我家的邮政编码"

❌ **不好的提示**：
- "密码是123456"（直接泄露密码）
- "和我的 Facebook 密码一样"（安全风险）

### 7.2 PBKDF2 迭代次数选择

| 迭代次数 | 安全性 | 性能（iPhone 12） | 推荐 |
|---------|--------|------------------|------|
| 10,000 | 低 | < 10ms | ❌ |
| 100,000 | 中 | ~100ms | ✅ 推荐 |
| 1,000,000 | 高 | ~1s | ⚪ 高安全场景 |

### 7.3 密钥管理

```objc
// ✅ 好的做法：密钥仅存在于内存中，使用完立即清除
NSData *key = [WFCCBackupCrypto deriveKeyFromPassword:...];
// 使用密钥...
// 使用完毕
key = nil;  // 让系统回收

// ❌ 不好的做法：将密钥写入日志或文件
NSLog(@"Key: %@", key);  // 永远不要这样做！
[key writeToURL:keyUrl atomically:YES];  // 也不要这样做！
```

---

## 8. 性能影响

### 8.1 加密性能

| 数据大小 | 加密时间 | 解密时间 | 内存占用 |
|---------|---------|---------|---------|
| 1MB | ~50ms | ~50ms | ~2MB |
| 10MB | ~400ms | ~400ms | ~12MB |
| 100MB | ~4s | ~4s | ~110MB |

*注：基于 iPhone 12，PBKDF2 100,000 次迭代*

### 8.2 优化建议

```objc
// 1. 分块加密（避免内存峰值）
- (void)encryptLargeFile:(NSString *)inputPath
                toFile:(NSString *)outputPath
              password:(NSString *)password
               chunkSize:(NSUInteger)chunkSize {  // 例如 1MB

    NSInputStream *input = [NSInputStream inputStreamWithFileAtPath:inputPath];
    NSOutputStream *output = [NSOutputStream outputStreamToFileAtPath:outputPath append:NO];

    [input open];
    [output open];

    uint8_t buffer[chunkSize];
    NSInteger bytesRead;

    while ((bytesRead = [input read:buffer maxLength:chunkSize]) > 0) {
        NSData *chunk = [NSData dataWithBytes:buffer length:bytesRead];

        // 加密这个块
        NSDictionary *encryptedChunk = [WFCCBackupCrypto encryptData:chunk
                                                             password:password
                                                                error:nil];

        // 写入加密后的数据
        [self writeEncryptedChunk:encryptedChunk toStream:output];
    }

    [input close];
    [output close];
}
```

---

## 9. 测试方案

### 9.1 单元测试

```objc
@interface WFCCBackupCryptoTests : XCTestCase
@end

@implementation WFCCBackupCryptoTests

// 测试基本的加密解密
- (void)testEncryptDecrypt {
    NSString *password = @"TestPassword123!";
    NSData *originalData = [@"Hello, World!" dataUsingEncoding:NSUTF8StringEncoding];

    NSError *error;
    NSDictionary *encrypted = [WFCCBackupCrypto encryptData:originalData
                                                   password:password
                                                      error:&error];

    XCTAssertNotNil(encrypted);
    XCTAssertNil(error);

    NSData *decrypted = [WFCCBackupCrypto decryptData:encrypted
                                             password:password
                                                error:&error];

    XCTAssertNotNil(decrypted);
    XCTAssertEqualObjects(decrypted, originalData);
}

// 测试密码验证
- (void)testPasswordVerification {
    NSString *correctPassword = @"CorrectPassword123";
    NSString *wrongPassword = @"WrongPassword456";

    NSData *data = [@"Secret Message" dataUsingEncoding:NSUTF8StringEncoding];
    NSDictionary *encrypted = [WFCCBackupCrypto encryptData:data
                                                   password:correctPassword
                                                      error:nil];

    // 正确密码
    BOOL isValid = [WFCCBackupCrypto verifyPassword:encrypted
                                           password:correctPassword];
    XCTAssertTrue(isValid);

    // 错误密码
    isValid = [WFCCBackupCrypto verifyPassword:encrypted
                                      password:wrongPassword];
    XCTAssertFalse(isValid);
}

@end
```

### 9.2 集成测试

```objc
@interface WFCCBackupEncryptionTests : XCTestCase
@property (nonatomic, strong) WFCCMessageBackupManager *backupManager;
@end

@implementation WFCCBackupEncryptionTests

- (void)setUp {
    [super setUp];
    self.backupManager = [WFCCMessageBackupManager sharedManager];
}

// 测试创建和恢复加密备份
- (void)testCreateAndRestoreEncryptedBackup {
    NSString *password = @"TestPassword123!";
    NSString *backupPath = @"/tmp/test_encrypted_backup.json";

    XCTestExpectation *createExpectation = [self expectationWithDescription:@"Backup created"];

    // 创建加密备份
    [self.backupManager createEncryptedBackup:backupPath
                                     password:password
                               passwordHint:@"测试提示"
                                includeMedia:NO
                                   progress:nil
                                    success:^(NSString *path) {
        // 验证备份文件存在
        XCTAssertTrue([[NSFileManager defaultManager] fileExistsAtPath:path]);

        // 验证可以获取公开信息
        NSDictionary *info = [self.backupManager getEncryptedBackupInfo:path];
        XCTAssertTrue([info[@"isEncrypted"] boolValue]);

        // 验证密码
        BOOL isValid = [self.backupManager verifyBackupPassword:path
                                                        password:password];
        XCTAssertTrue(isValid);

        [createExpectation fulfill];
    } error:^(int errorCode) {
        XCTFail(@"Backup creation failed with error: %d", errorCode);
    }];

    [self waitForExpectationsWithTimeout:30.0 handler:nil];

    // 恢复备份
    XCTestExpectation *restoreExpectation = [self expectationWithDescription:@"Backup restored"];

    [self.backupManager restoreEncryptedBackup:backupPath
                                      password:password
                            overwriteExisting:YES
                                mediaBasePath:nil
                                     progress:nil
                                      success:^(int msgCount, int mediaCount) {
        XCTAssertGreaterThan(msgCount, 0);
        [restoreExpectation fulfill];
    } error:^(int errorCode) {
        XCTFail(@"Restore failed with error: %d", errorCode);
    }];

    [self waitForExpectationsWithTimeout:60.0 handler:nil];
}

// 测试错误密码
- (void)testWrongPassword {
    NSString *correctPassword = @"CorrectPassword123";
    NSString *wrongPassword = @"WrongPassword456";
    NSString *backupPath = @"/tmp/test_wrong_password.json";

    XCTestExpectation *createExpectation = [self expectationWithDescription:@"Backup created"];

    [self.backupManager createEncryptedBackup:backupPath
                                     password:correctPassword
                               passwordHint:nil
                                includeMedia:NO
                                   progress:nil
                                    success:^(NSString *path) {
        [createExpectation fulfill];
    } error:^(int errorCode) {
        XCTFail(@"Backup creation failed");
    }];

    [self waitForExpectationsWithTimeout:30.0 handler:nil];

    // 尝试用错误密码恢复
    XCTestExpectation *restoreExpectation = [self expectationWithDescription:@"Restore should fail"];

    [self.backupManager restoreEncryptedBackup:backupPath
                                      password:wrongPassword
                            overwriteExisting:YES
                                mediaBasePath:nil
                                     progress:nil
                                      success:^(int msgCount, int mediaCount) {
        XCTFail(@"Restore should not succeed with wrong password");
        [restoreExpectation fulfill];
    } error:^(int errorCode) {
        XCTAssertEqual(errorCode, BackupError_WrongPassword);
        [restoreExpectation fulfill];
    }];

    [self waitForExpectationsWithTimeout:30.0 handler:nil];
}

@end
```

---

## 10. 总结

### 10.1 加密方案特点

✅ **安全性**
- AES-256-CBC 行业标准加密
- PBKDF2 密钥派生，防暴力破解
- 每次加密使用不同的 Salt 和 IV

✅ **可用性**
- 支持密码提示
- 可以查看备份基本信息（无需解密）
- 实时密码验证

✅ **性能**
- 合理的迭代次数（100,000）
- 原生 CCCrypt 支持，性能优异
- 内存占用可控

✅ **兼容性**
- iOS 原生 CommonCrypto API
- 无需第三方加密库
- 兼容所有 iOS 版本

### 10.2 使用建议

1. **默认启用加密**：推荐用户使用加密备份
2. **保存密码提示**：帮助用户记忆密码
3. **测试备份**：备份后立即测试恢复
4. **多地备份**：加密后可以安全地上传到云存储

### 10.3 后续增强

- ✅ 生物识别解锁（Touch ID / Face ID）
- ✅ iCloud Keychain 集成
- ✅ 硬件安全模块（Secure Enclave）
- ✅ 端到端加密的云备份
